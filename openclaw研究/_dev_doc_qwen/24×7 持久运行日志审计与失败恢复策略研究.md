# 24×7 持久运行下的日志、审计与失败恢复策略

**研究对象**: OpenClaw (https://github.com/openclaw/openclaw)  
**研究日期**: 2026 年 2 月 18 日  
**研究目标**: 分析 OpenClaw 在长期运行场景下的可观测性、健康监控与故障恢复机制

---

## 1. 执行摘要

OpenClaw 是一个设计用于 24×7 持续运行的个人 AI 助手网关系统。通过深入分析其代码库，本研究发现 OpenClaw 建立了一套相对完整但仍有改进空间的持久运行保障体系：

### 核心发现

| 领域 | 成熟度 | 关键机制 |
|------|--------|----------|
| **日志系统** | ✅ 成熟 | 分层日志 (文件 + 控制台)、JSONL 格式、子系统隔离、敏感信息脱敏 |
| **诊断事件** | ✅ 成熟 | 结构化事件总线、13+ 事件类型、心跳聚合、支持 OpenTelemetry 导出 |
| **健康监控** | ⚠️ 中等 | 网关健康快照、渠道状态探测、会话 stuck 检测 |
| **失败恢复** | ✅ 成熟 | 模型故障转移、认证档案轮换、重试策略、工具循环检测 |
| **审计系统** | ✅ 成熟 | 安全审计 (60+ 检查项)、配置修复、权限检查 |
| **自动修复** | ✅ 成熟 | Doctor 命令、配置迁移、服务修复 |

### 关键指标

- **日志文件**: 按日滚动 `/tmp/openclaw/openclaw-YYYY-MM-DD.log`
- **诊断事件**: 13 种类型，30 秒心跳周期
- **健康检查**: 渠道探测、会话状态、队列深度
- **故障转移**: 5 种失败类型识别 (billing/rate_limit/auth/timeout/format)
- **审计检查**: 6 大类 60+ 检查项
- **恢复机制**: 自动重试 (3 次默认)、电路断路器 (30 次阈值)

---

## 2. 高可观测性 (Traceability) 体系设计

### 2.1 分层日志架构

OpenClaw 采用**双层日志架构**：

```
┌─────────────────────────────────────────────────────────┐
│                    应用层                                │
│  子系统日志 (Subsystem Logger)                           │
│  - gateway/channels/whatsapp                            │
│  - agents/loop-detection                                │
│  - infra/heartbeat                                      │
├─────────────────────────────────────────────────────────┤
│                    传输层                                │
│  ┌─────────────────┐  ┌─────────────────┐              │
│  │   文件日志      │  │   控制台日志    │              │
│  │   (JSONL)       │  │   (TTY 感知)     │              │
│  │   持久化        │  │   交互式        │              │
│  └─────────────────┘  └─────────────────┘              │
├─────────────────────────────────────────────────────────┤
│                    导出层                                │
│  ┌─────────────────┐  ┌─────────────────┐              │
│  │  OpenTelemetry  │  │  诊断事件总线   │              │
│  │  (OTLP/HTTP)    │  │  (in-process)   │              │
│  └─────────────────┘  └─────────────────┘              │
└─────────────────────────────────────────────────────────┘
```

### 2.2 日志子系统

**核心模块**: `src/logging/`

```typescript
// src/logging/subsystem.ts
export function createSubsystemLogger(subsystem: string): SubsystemLogger {
  return {
    debug: (msg) => log.debug(`[${subsystem}] ${msg}`),
    info: (msg) => log.info(`[${subsystem}] ${msg}`),
    warn: (msg) => log.warn(`[${subsystem}] ${msg}`),
    error: (msg) => log.error(`[${subsystem}] ${msg}`),
  };
}
```

**子系统命名规范**:
```
gateway/heartbeat      - 心跳运行
gateway/channels       - 渠道管理
agents/loop-detection  - 工具循环检测
infra/retry            - 重试机制
diagnostic             - 诊断事件
```

### 2.3 日志配置

```json
{
  "logging": {
    "level": "info",           // 文件日志级别
    "file": "/tmp/openclaw/openclaw-YYYY-MM-DD.log",
    "consoleLevel": "info",    // 控制台级别
    "consoleStyle": "pretty",  // pretty/compact/json
    "redactSensitive": "tools", // 敏感信息脱敏
    "redactPatterns": ["sk-.*"] // 自定义脱敏模式
  }
}
```

**日志级别层次**:
```
silent (∞) > fatal (0) > error (1) > warn (2) > info (3) > debug (4) > trace (5)
```

### 2.4 诊断事件系统

**核心模块**: `src/infra/diagnostic-events.ts`

诊断事件是**结构化、机器可读**的事件流，用于指标、追踪和告警。

#### 事件类型目录 (13 种)

| 事件类型 | 用途 | 关键字段 |
|----------|------|----------|
| `model.usage` | 模型使用指标 | tokens, cost, duration, context |
| `webhook.received` | Webhook 入口 | channel, updateType, chatId |
| `webhook.processed` | Webhook 处理 | channel, durationMs |
| `webhook.error` | Webhook 错误 | channel, error |
| `message.queued` | 消息入队 | sessionId, source, queueDepth |
| `message.processed` | 消息处理 | outcome, durationMs, error |
| `session.state` | 会话状态变更 | prevState, state, reason |
| `session.stuck` | 会话卡住警告 | state, ageMs, queueDepth |
| `queue.lane.enqueue` | 队列入队 | lane, queueSize |
| `queue.lane.dequeue` | 队列出队 | lane, waitMs, queueSize |
| `run.attempt` | 运行重试 | runId, attempt |
| `diagnostic.heartbeat` | 心跳聚合 | webhooks, active, waiting, queued |
| `tool.loop` | 工具循环检测 | toolName, level, detector, count |

#### 事件结构

```typescript
type DiagnosticBaseEvent = {
  ts: number;      // 时间戳 (Date.now())
  seq: number;     // 序列号 (全局递增)
};

type DiagnosticUsageEvent = DiagnosticBaseEvent & {
  type: "model.usage";
  sessionKey?: string;
  sessionId?: string;
  channel?: string;
  provider?: string;
  model?: string;
  usage: {
    input?: number;
    output?: number;
    cacheRead?: number;
    cacheWrite?: number;
    total?: number;
  };
  costUsd?: number;
  durationMs?: number;
};
```

#### 事件发射器

```typescript
// src/logging/diagnostic.ts
export function emitDiagnosticEvent(event: DiagnosticEventInput) {
  const enriched = {
    ...event,
    seq: (seq += 1),  // 全局序列号
    ts: Date.now(),   // 时间戳
  } satisfies DiagnosticEventPayload;
  
  for (const listener of listeners) {
    try {
      listener(enriched);  // 同步通知所有监听器
    } catch {
      // 忽略监听器失败，避免阻塞
    }
  }
}
```

### 2.5 OpenTelemetry 集成

**导出插件**: `diagnostics-otel`

```json
{
  "plugins": {
    "allow": ["diagnostics-otel"],
    "entries": {
      "diagnostics-otel": {
        "enabled": true
      }
    }
  },
  "diagnostics": {
    "enabled": true,
    "otel": {
      "enabled": true,
      "endpoint": "http://otel-collector:4318",
      "protocol": "http/protobuf",
      "serviceName": "openclaw-gateway",
      "traces": true,
      "metrics": true,
      "logs": true,
      "sampleRate": 0.2,
      "flushIntervalMs": 60000
    }
  }
}
```

#### 导出指标 (18 种)

**模型使用**:
- `openclaw.tokens` (counter) - Token 消耗
- `openclaw.cost.usd` (counter) - 成本
- `openclaw.run.duration_ms` (histogram) - 运行时长
- `openclaw.context.tokens` (histogram) - 上下文大小

**消息流**:
- `openclaw.webhook.received` (counter)
- `openclaw.webhook.error` (counter)
- `openclaw.webhook.duration_ms` (histogram)
- `openclaw.message.queued` (counter)
- `openclaw.message.processed` (counter)
- `openclaw.message.duration_ms` (histogram)

**队列与会话**:
- `openclaw.queue.lane.enqueue` (counter)
- `openclaw.queue.depth` (histogram)
- `openclaw.queue.wait_ms` (histogram)
- `openclaw.session.state` (counter)
- `openclaw.session.stuck` (counter)
- `openclaw.session.stuck_age_ms` (histogram)

#### 导出追踪 Span (5 种)

| Span 名称 | 关键属性 |
|-----------|----------|
| `openclaw.model.usage` | provider, model, tokens.*, sessionKey |
| `openclaw.webhook.processed` | channel, webhook, chatId |
| `openclaw.webhook.error` | channel, error |
| `openclaw.message.processed` | channel, outcome, sessionId |
| `openclaw.session.stuck` | state, ageMs, queueDepth |

---

## 3. 健康运行监控核心指标

### 3.1 网关健康快照

**核心模块**: `src/commands/health.ts`

```typescript
type HealthSummary = {
  ok: true;
  ts: number;
  durationMs: number;
  channels: Record<string, ChannelHealthSummary>;
  channelOrder: string[];
  channelLabels: Record<string, string>;
  heartbeatSeconds: number;
  defaultAgentId: string;
  agents: AgentHealthSummary[];
  sessions: {
    path: string;
    count: number;
    recent: Array<{ key: string; updatedAt: number | null; age: number | null }>;
  };
};
```

### 3.2 渠道健康指标

```typescript
type ChannelHealthSummary = {
  accountId: string;
  configured?: boolean;    // 是否配置
  linked?: boolean;        // 是否连接
  authAgeMs?: number | null;  // 认证时长
  probe?: unknown;         // 探测结果
  lastProbeAt?: number | null; // 最后探测时间
};
```

**探测机制**:
```typescript
// src/gateway/probe.ts
export async function probeGateway(deps: ProbeDeps) {
  const connection = buildGatewayConnectionDetails(deps);
  const ws = await connectWebSocket(connection.url);
  
  // 发送 probe 请求
  const result = await callGateway(connection, {
    method: "health.probe",
    params: { channels: true },
  });
  
  return {
    ok: true,
    channels: result.channels,
    durationMs: Date.now() - startTime,
  };
}
```

### 3.3 会话状态监控

**核心模块**: `src/logging/diagnostic-session-state.ts`

```typescript
type SessionState = "idle" | "processing" | "waiting";

type SessionStateValue = {
  sessionId?: string;
  sessionKey?: string;
  state: SessionState;
  queueDepth: number;
  lastActivity: number;
};

// 全局状态追踪
const diagnosticSessionStates = new Map<string, SessionStateValue>();
```

**状态转换追踪**:
```typescript
// src/logging/diagnostic.ts
export function logSessionStateChange(params: SessionRef & {
  state: SessionStateValue;
  reason?: string;
}) {
  const state = getDiagnosticSessionState(params);
  const prevState = state.state;
  state.state = params.state;
  state.lastActivity = Date.now();
  
  emitDiagnosticEvent({
    type: "session.state",
    sessionId: state.sessionId,
    sessionKey: state.sessionKey,
    prevState,
    state: params.state,
    reason: params.reason,
    queueDepth: state.queueDepth,
  });
}
```

### 3.4 心跳机制

**核心模块**: `src/infra/heartbeat-runner.ts`

```typescript
type HeartbeatConfig = {
  every?: string;        // 间隔 (如 "60s", "5m")
  prompt?: string;       // 心跳提示词
  target?: string;       // 发送目标 ("last" 或具体渠道)
  model?: string;        // 使用的模型
  ackMaxChars?: number;  // 确认最大字符数
};
```

**心跳运行器**:
```typescript
export function startHeartbeatRunner(config: OpenClawConfig): HeartbeatRunner {
  const agents = resolveHeartbeatAgents(config);
  const states = new Map<string, HeartbeatAgentState>();
  
  // 为每个代理创建定时任务
  for (const agent of agents) {
    const intervalMs = resolveHeartbeatIntervalMs(config, agent);
    states.set(agent.agentId, {
      agentId: agent.agentId,
      intervalMs,
      nextDueMs: Date.now() + intervalMs,
    });
  }
  
  // 每秒检查一次
  const timer = setInterval(() => {
    const now = Date.now();
    for (const [agentId, state] of states) {
      if (now >= state.nextDueMs) {
        runHeartbeat(agentId, config);
        state.lastRunMs = now;
        state.nextDueMs = now + state.intervalMs;
      }
    }
  }, 1000);
  
  return {
    stop: () => clearInterval(timer),
    updateConfig: (cfg) => { /* 更新配置 */ },
  };
}
```

### 3.5 队列监控

**核心模块**: `src/process/command-queue.ts`

```typescript
type LaneState = {
  lane: string;
  queue: QueueEntry[];
  activeTaskIds: Set<number>;
  maxConcurrent: number;
  draining: boolean;
  generation: number;
};

// 多车道队列系统
const lanes = new Map<string, LaneState>();
```

**队列指标**:
- **队列深度**: `state.queue.length + state.activeTaskIds.size`
- **等待时间**: `Date.now() - entry.enqueuedAt`
- **活跃任务**: `state.activeTaskIds.size`

**诊断事件**:
```typescript
export function logLaneEnqueue(lane: string, queueSize: number) {
  diag.debug(`lane enqueue: lane=${lane} queueSize=${queueSize}`);
  emitDiagnosticEvent({
    type: "queue.lane.enqueue",
    lane,
    queueSize,
  });
}

export function logLaneDequeue(lane: string, waitMs: number, queueSize: number) {
  diag.debug(`lane dequeue: lane=${lane} waitMs=${waitMs} queueSize=${queueSize}`);
  emitDiagnosticEvent({
    type: "queue.lane.dequeue",
    lane,
    queueSize,
    waitMs,
  });
}
```

### 3.6 卡住会话检测

**检测逻辑**: `src/logging/diagnostic.ts`

```typescript
// 心跳回调中检测
setInterval(() => {
  for (const [, state] of diagnosticSessionStates) {
    const ageMs = Date.now() - state.lastActivity;
    
    // 超过 2 分钟处于 processing 状态 = 卡住
    if (state.state === "processing" && ageMs > 120_000) {
      logSessionStuck({
        sessionId: state.sessionId,
        sessionKey: state.sessionKey,
        state: state.state,
        ageMs,
      });
    }
  }
}, 30_000);  // 每 30 秒检查一次
```

**告警事件**:
```typescript
export function logSessionStuck(params: SessionRef & {
  state: SessionStateValue;
  ageMs: number;
}) {
  diag.warn(
    `stuck session: sessionId=${state.sessionId ?? "unknown"} ` +
    `state=${params.state} age=${Math.round(params.ageMs / 1000)}s`
  );
  emitDiagnosticEvent({
    type: "session.stuck",
    sessionId: state.sessionId,
    sessionKey: state.sessionKey,
    state: params.state,
    ageMs: params.ageMs,
    queueDepth: state.queueDepth,
  });
}
```

### 3.7 核心监控指标汇总

| 类别 | 指标 | 阈值 | 告警级别 |
|------|------|------|----------|
| **网关** | 运行时长 (uptime) | - | info |
| | 健康检查延迟 | >10s | warn |
| **渠道** | 认证过期时间 | <24h | warn |
| | 最后探测时间 | >5m | warn |
| **会话** | 处理中时长 | >2m | warn |
| | 等待中时长 | >5m | warn |
| | 队列深度 | >10 | warn |
| **队列** | 等待时间 | >30s | warn |
| | 车道并发 | >maxConcurrent | error |
| **模型** | 失败率 | >10% | warn |
| | 平均响应时间 | >30s | warn |
| **Token** | 上下文使用率 | >80% | warn |
| | 每小时成本 | >$1 | info |

---

## 4. 失败恢复策略

### 4.1 模型故障转移 (Failover)

**核心模块**: `src/agents/failover-error.ts`

#### 失败类型识别

```typescript
type FailoverReason = 
  | "billing"      // 402 - 账单问题
  | "rate_limit"   // 429 - 速率限制
  | "auth"         // 401/403 - 认证失败
  | "timeout"      // 408 - 超时
  | "format";      // 400 - 格式错误

export function resolveFailoverReasonFromError(err: unknown): FailoverReason | null {
  // 1. 检查状态码
  const status = getStatusCode(err);
  if (status === 402) return "billing";
  if (status === 429) return "rate_limit";
  if (status === 401 || status === 403) return "auth";
  if (status === 408) return "timeout";
  if (status === 400) return "format";
  
  // 2. 检查错误码
  const code = getErrorCode(err)?.toUpperCase();
  if (["ETIMEDOUT", "ESOCKETTIMEDOUT", "ECONNRESET"].includes(code)) {
    return "timeout";
  }
  
  // 3. 检查错误消息
  const message = getErrorMessage(err);
  return classifyFailoverReason(message);
}
```

#### 故障转移错误类

```typescript
export class FailoverError extends Error {
  readonly reason: FailoverReason;
  readonly provider?: string;
  readonly model?: string;
  readonly profileId?: string;
  readonly status?: number;
  readonly code?: string;

  constructor(message: string, params: {
    reason: FailoverReason;
    provider?: string;
    model?: string;
    profileId?: string;
    status?: number;
    code?: string;
    cause?: unknown;
  }) {
    super(message, { cause: params.cause });
    this.name = "FailoverError";
    // ... 赋值
  }
}
```

### 4.2 认证档案轮换

**核心模块**: `src/agents/auth-profiles/`

#### 认证档案结构

```typescript
type AuthProfileCredential = 
  | { type: "api_key"; apiKey: string }
  | { type: "oauth"; accessToken: string; refreshToken?: string; expiresAt?: number }
  | { type: "token"; token: string };

type AuthProfileStore = Record<string, {
  id: string;
  provider: string;
  credentials: AuthProfileCredential[];
  lastUsedAt?: number;
  lastGoodAt?: number;
  errorCount?: number;
  disabled?: boolean;
}>;
```

#### 失败标记与冷却

```typescript
// src/agents/auth-profiles/usage.ts
export function markAuthProfileFailure(
  store: AuthProfileStore,
  profileId: string,
  reason: AuthProfileFailureReason,
): void {
  const profile = store[profileId];
  if (!profile) return;
  
  profile.errorCount = (profile.errorCount ?? 0) + 1;
  
  // 根据失败原因设置冷却时间
  const cooldownMs = calculateAuthProfileCooldownMs(reason);
  if (cooldownMs > 0) {
    markAuthProfileCooldown(store, profileId, cooldownMs);
  }
  
  // 连续失败 5 次禁用
  if (profile.errorCount >= 5) {
    profile.disabled = true;
  }
  
  saveAuthProfileStore(store);
}

export function calculateAuthProfileCooldownMs(reason: AuthProfileFailureReason): number {
  switch (reason) {
    case "rate_limit":
      return 5 * 60 * 1000;  // 5 分钟
    case "billing":
      return 30 * 60 * 1000; // 30 分钟
    case "timeout":
      return 2 * 60 * 1000;  // 2 分钟
    default:
      return 0;
  }
}
```

#### 档案选择策略

```typescript
// src/agents/auth-profiles/order.ts
export function resolveAuthProfileOrder(
  store: AuthProfileStore,
  provider: string,
): string[] {
  const profiles = Object.values(store).filter(
    p => p.provider === provider && !p.disabled
  );
  
  // 过滤掉冷却中的档案
  const now = Date.now();
  const available = profiles.filter(p => {
    if (!p.cooldownUntil) return true;
    return now >= p.cooldownUntil;
  });
  
  // 优先选择最近成功的
  available.sort((a, b) => {
    if (b.lastGoodAt && a.lastGoodAt) return b.lastGoodAt - a.lastGoodAt;
    if (b.lastUsedAt && a.lastUsedAt) return b.lastUsedAt - a.lastUsedAt;
    return 0;
  });
  
  return available.map(p => p.id);
}
```

### 4.3 重试策略

**核心模块**: `src/infra/retry.ts`

```typescript
type RetryConfig = {
  attempts?: number;      // 最大尝试次数 (默认 3)
  minDelayMs?: number;    // 最小延迟 (默认 300ms)
  maxDelayMs?: number;    // 最大延迟 (默认 30s)
  jitter?: number;        // 抖动系数 (0-1, 默认 0)
};

export async function retryAsync<T>(
  fn: () => Promise<T>,
  attemptsOrOptions: number | RetryOptions = 3,
  initialDelayMs = 300,
): Promise<T> {
  const resolved = resolveRetryConfig(DEFAULT_RETRY_CONFIG, options);
  const maxAttempts = resolved.attempts;
  const minDelayMs = resolved.minDelayMs;
  const maxDelayMs = resolved.maxDelayMs;
  const jitter = resolved.jitter;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
    try {
      return await fn();
    } catch (err) {
      if (attempt >= maxAttempts) break;
      
      // 指数退避 + 抖动
      const baseDelay = minDelayMs * 2 ** (attempt - 1);
      let delay = Math.min(baseDelay, maxDelayMs);
      delay = applyJitter(delay, jitter);
      
      await sleep(delay);
    }
  }
  throw lastErr ?? new Error("Retry failed");
}

function applyJitter(delayMs: number, jitter: number): number {
  if (jitter <= 0) return delayMs;
  const offset = (Math.random() * 2 - 1) * jitter;
  return Math.max(0, Math.round(delayMs * (1 + offset)));
}
```

### 4.4 工具循环检测与电路断路器

**核心模块**: `src/agents/tool-loop-detection.ts`

#### 循环检测配置

```typescript
const DEFAULT_LOOP_DETECTION_CONFIG = {
  enabled: false,
  historySize: 30,              // 工具调用历史大小
  warningThreshold: 10,         // 警告阈值
  criticalThreshold: 20,        // 严重阈值
  globalCircuitBreakerThreshold: 30,  // 全局电路断路器阈值
  detectors: {
    genericRepeat: true,        // 通用重复检测
    knownPollNoProgress: true,  // 已知轮询无进展检测
    pingPong: true,             // 乒乓检测
  },
};
```

#### 检测器实现

```typescript
export function detectToolLoop(
  toolName: string,
  params: unknown,
  outcome: "progress" | "no_progress" | "error",
  sessionState: SessionState,
  config?: ToolLoopDetectionConfig,
): LoopDetectionResult {
  const resolvedConfig = resolveLoopDetectionConfig(config);
  
  if (!resolvedConfig.enabled) {
    return { stuck: false };
  }
  
  // 1. 通用重复检测
  if (resolvedConfig.detectors.genericRepeat) {
    const result = detectGenericRepeat(toolName, params, sessionState, resolvedConfig);
    if (result.stuck) return result;
  }
  
  // 2. 已知轮询工具无进展检测
  if (resolvedConfig.detectors.knownPollNoProgress) {
    const result = detectKnownPollNoProgress(toolName, outcome, sessionState, resolvedConfig);
    if (result.stuck) return result;
  }
  
  // 3. 乒乓检测 (两个工具交替调用)
  if (resolvedConfig.detectors.pingPong) {
    const result = detectPingPong(toolName, sessionState, resolvedConfig);
    if (result.stuck) return result;
  }
  
  return { stuck: false };
}
```

#### 全局电路断路器

```typescript
export function checkGlobalCircuitBreaker(
  toolName: string,
  sessionState: SessionState,
  config: ResolvedLoopDetectionConfig,
): LoopDetectionResult {
  const noProgressStreak = sessionState.noProgressStreak ?? 0;
  
  if (noProgressStreak >= config.globalCircuitBreakerThreshold) {
    return {
      stuck: true,
      level: "critical",
      detector: "global_circuit_breaker",
      count: noProgressStreak,
      message: `CRITICAL: ${toolName} has repeated identical no-progress outcomes ` +
               `${noProgressStreak} times. Session execution blocked by global circuit breaker.`,
    };
  }
  
  return { stuck: false };
}
```

#### 检测器触发条件

| 检测器 | 触发条件 | 级别 | 动作 |
|--------|----------|------|------|
| generic_repeat | 相同工具调用重复 10/20/30 次 | warning/critical | 警告/阻止 |
| known_poll_no_progress | 轮询工具无进展 10/20/30 次 | warning/critical | 警告/阻止 |
| ping_pong | 两个工具交替调用 10/20/30 次 | warning/critical | 警告/阻止 |
| global_circuit_breaker | 无进展累计 30 次 | critical | 阻止会话执行 |

### 4.5 网关重启机制

**核心模块**: `src/infra/restart.ts`

#### SIGUSR1 优雅重启

```typescript
let sigusr1AuthorizedCount = 0;
let sigusr1AuthorizedUntil = 0;
let restartCycleToken = 0;
let emittedRestartToken = 0;
let consumedRestartToken = 0;

export function emitGatewayRestart(): boolean {
  if (hasUnconsumedRestartSignal()) {
    return false;  // 避免重复重启
  }
  
  const cycleToken = ++restartCycleToken;
  emittedRestartToken = cycleToken;
  authorizeGatewaySigusr1Restart();
  
  try {
    if (process.listenerCount("SIGUSR1") > 0) {
      process.emit("SIGUSR1");
    } else {
      process.kill(process.pid, "SIGUSR1");
    }
  } catch {
    emittedRestartToken = consumedRestartToken;  // 回滚
    return false;
  }
  return true;
}
```

#### 延迟重启 (等待空闲)

```typescript
export function deferGatewayRestartUntilIdle(opts: {
  getPendingCount: () => number;
  hooks?: RestartDeferralHooks;
  pollMs?: number;
  maxWaitMs?: number;
}): void {
  const pollMs = opts.pollMs ?? 500;
  const maxWaitMs = opts.maxWaitMs ?? 30_000;
  
  let pending = opts.getPendingCount();
  if (pending <= 0) {
    opts.hooks?.onReady?.();
    emitGatewayRestart();
    return;
  }
  
  opts.hooks?.onDeferring?.(pending);
  const startedAt = Date.now();
  
  const poll = setInterval(() => {
    const current = opts.getPendingCount();
    if (current <= 0) {
      clearInterval(poll);
      opts.hooks?.onReady?.();
      emitGatewayRestart();
      return;
    }
    
    const elapsedMs = Date.now() - startedAt;
    if (elapsedMs >= maxWaitMs) {
      clearInterval(poll);
      opts.hooks?.onTimeout?.(current, elapsedMs);
      emitGatewayRestart();
    }
  }, pollMs);
}
```

#### 平台特定重启

```typescript
export function triggerOpenClawRestart(): RestartAttempt {
  if (process.platform === "darwin") {
    // macOS: launchctl
    const label = resolveGatewayLaunchAgentLabel();
    const result = spawnSync("launchctl", ["kickstart", "-k", label]);
    return { ok: result.status === 0, method: "launchctl" };
  }
  
  if (process.platform === "linux") {
    // Linux: systemd
    const unit = resolveGatewaySystemdServiceName();
    const userRestart = spawnSync("systemctl", ["--user", "restart", unit]);
    if (userRestart.status === 0) {
      return { ok: true, method: "systemd" };
    }
    const systemRestart = spawnSync("systemctl", ["restart", unit]);
    return { ok: systemRestart.status === 0, method: "systemd" };
  }
  
  return { ok: false, method: "supervisor", detail: "unsupported platform" };
}
```

### 4.6 Doctor 自动修复

**核心模块**: `src/commands/doctor*.ts`

#### Doctor 检查项

| 类别 | 检查项 | 修复动作 |
|------|--------|----------|
| **配置** | 配置规范化 | 迁移旧格式 |
| | 遗留键迁移 | 自动转换 |
| | 权限检查 | chmod 600 |
| **状态** | 会话存储迁移 | 移动文件 |
| | 凭证迁移 | 重组目录 |
| | 状态完整性 | 验证 JSON |
| **服务** | 服务状态检查 | 重启服务 |
| | 额外网关检测 | 提示清理 |
| | Supervisor 配置 | 修复配置 |
| **安全** | 开放 DM 策略 | 警告 |
| | 沙箱配置 | 修复镜像 |
| | 技能安全 | 扫描代码 |
| **认证** | OAuth 过期 | 刷新令牌 |
| | 认证档案冷却 | 报告状态 |
| | CLI 档案清理 | 移除旧档案 |

#### Doctor 运行流程

```typescript
// src/commands/doctor.ts (简化)
export async function runDoctor(options: DoctorOptions): Promise<void> {
  const findings: DoctorFinding[] = [];
  
  // 1. 配置检查
  const configCheck = await checkConfig();
  findings.push(...configCheck);
  
  // 2. 健康检查
  const healthCheck = await checkHealth();
  findings.push(...healthCheck);
  
  // 3. 服务检查
  const serviceCheck = await checkServices();
  findings.push(...serviceCheck);
  
  // 4. 安全审计
  const auditCheck = await runSecurityAudit();
  findings.push(...auditCheck);
  
  // 5. 应用修复
  if (options.repair) {
    for (const finding of findings) {
      if (finding.autoFix) {
        await finding.autoFix();
      }
    }
  }
  
  // 6. 报告结果
  printReport(findings);
}
```

---

## 5. 审计系统

### 5.1 安全审计框架

**核心模块**: `src/security/audit.ts`

```typescript
type SecurityAuditFinding = {
  checkId: string;
  severity: "info" | "warn" | "critical";
  title: string;
  detail: string;
  remediation?: string;
};

type SecurityAuditReport = {
  ts: number;
  summary: {
    critical: number;
    warn: number;
    info: number;
  };
  findings: SecurityAuditFinding[];
  deep?: {
    gateway?: {
      attempted: boolean;
      url: string | null;
      ok: boolean;
      error: string | null;
    };
  };
};
```

### 5.2 审计检查类别

#### 1. 文件系统安全

```typescript
async function collectFilesystemFindings(params: {
  stateDir: string;
  configPath: string;
}): Promise<SecurityAuditFinding[]> {
  const findings: SecurityAuditFinding[] = [];
  
  // 检查状态目录权限
  const stateDirPerms = await inspectPathPermissions(params.stateDir);
  if (stateDirPerms.worldWritable) {
    findings.push({
      checkId: "fs.state_dir.perms_world_writable",
      severity: "critical",
      title: "State dir is world-writable",
      detail: `${params.stateDir} is writable by other users`,
      remediation: `chmod 700 ${params.stateDir}`,
    });
  }
  
  // 检查配置文件权限
  const configPerms = await inspectPathPermissions(params.configPath);
  if (configPerms.groupReadable || configPerms.worldReadable) {
    findings.push({
      checkId: "fs.config_dir.perms_too_open",
      severity: "critical",
      title: "Config file is readable by others",
      detail: `${params.configPath} may contain secrets`,
      remediation: `chmod 600 ${params.configPath}`,
    });
  }
  
  return findings;
}
```

#### 2. 渠道安全

```typescript
// src/security/audit-channel.ts
export function collectChannelSecurityFindings(
  config: OpenClawConfig,
): SecurityAuditFinding[] {
  const findings: SecurityAuditFinding[] = [];
  
  // 检查开放 DM 策略
  for (const channel of ["discord", "slack", "telegram"]) {
    const channelConfig = config.channels?.[channel];
    if (channelConfig?.dmPolicy === "open") {
      findings.push({
        checkId: `channel.${channel}.dm_policy_open`,
        severity: "warn",
        title: `${channel} DM policy is "open"`,
        detail: "Unknown senders can message the bot",
        remediation: `Set channels.${channel}.dmPolicy to "pairing"`,
      });
    }
  }
  
  // 检查允许列表通配符
  for (const [channel, channelConfig] of Object.entries(config.channels || {})) {
    if (Array.isArray(channelConfig?.allowFrom) && channelConfig.allowFrom.includes("*")) {
      findings.push({
        checkId: `channel.${channel}.allow_from_wildcard`,
        severity: "warn",
        title: `${channel} allowFrom includes "*"`,
        detail: "Anyone can send messages",
        remediation: `Remove "*" from channels.${channel}.allowFrom`,
      });
    }
  }
  
  return findings;
}
```

#### 3. 模型卫生

```typescript
// src/security/audit-extra.ts
export function collectModelHygieneFindings(
  config: OpenClawConfig,
): SecurityAuditFinding[] {
  const findings: SecurityAuditFinding[] = [];
  
  // 检查小模型风险
  if (config.agents?.defaults?.models?.primary) {
    const model = config.agents.defaults.models.primary;
    if (isSmallModel(model)) {
      findings.push({
        checkId: "models.small_model_risk",
        severity: "warn",
        title: "Primary model may be too small",
        detail: `${model} may have weaker prompt-injection resistance`,
        remediation: "Consider using Claude Opus or GPT-4 for sensitive tasks",
      });
    }
  }
  
  // 检查认证配置
  if (!config.gateway?.auth?.token && config.gateway?.bind !== "loopback") {
    findings.push({
      checkId: "gateway.auth_missing",
      severity: "critical",
      title: "Gateway has no auth token",
      detail: "Gateway is accessible without authentication",
      remediation: "Set gateway.auth.token or bind to loopback",
    });
  }
  
  return findings;
}
```

#### 4. 沙箱配置

```typescript
export function collectSandboxDangerousConfigFindings(
  config: OpenClawConfig,
): SecurityAuditFinding[] {
  const findings: SecurityAuditFinding[] = [];
  
  const sandboxConfig = config.agents?.defaults?.sandbox;
  if (!sandboxConfig) return findings;
  
  // 检查沙箱模式
  if (sandboxConfig.mode === "none") {
    findings.push({
      checkId: "sandbox.mode_none",
      severity: "info",
      title: "Sandboxing is disabled",
      detail: "All sessions run without isolation",
      remediation: "Consider using sandbox.mode: 'non-main'",
    });
  }
  
  // 检查允许列表
  const allowlist = sandboxConfig.allowlist ?? [];
  if (allowlist.includes("bash") && allowlist.includes("*")) {
    findings.push({
      checkId: "sandbox.allowlist_too_permissive",
      severity: "warn",
      title: "Sandbox allowlist is too permissive",
      detail: "All tools including bash are allowed",
      remediation: "Restrict sandbox allowlist to necessary tools only",
    });
  }
  
  return findings;
}
```

#### 5. 插件与技能安全

```typescript
export function collectPluginsCodeSafetyFindings(
  config: OpenClawConfig,
): Promise<SecurityAuditFinding[]> {
  const findings: SecurityAuditFinding[] = [];
  
  // 扫描已安装插件
  for (const [pluginName, pluginConfig] of Object.entries(config.plugins?.entries || {})) {
    if (!pluginConfig.enabled) continue;
    
    // 检查插件来源
    if (!pluginConfig.source?.startsWith("npm:")) {
      findings.push({
        checkId: `plugin.${pluginName}.unknown_source`,
        severity: "warn",
        title: `Plugin ${pluginName} from unknown source`,
        detail: "Local or git plugins are not verified",
        remediation: "Review plugin code before enabling",
      });
    }
  }
  
  // 扫描技能代码
  const skillFindings = scanInstalledSkills(config);
  findings.push(...skillFindings);
  
  return findings;
}
```

### 5.3 后压缩审计 (Post-Compaction Audit)

**核心模块**: `src/auto-reply/reply/post-compaction-audit.ts`

这是一个特殊的审计机制，用于确保 AI 代理在上下文压缩后重新读取必要的启动文件。

```typescript
// 默认必需文件
const DEFAULT_REQUIRED_READS: Array<string | RegExp> = [
  "WORKFLOW_AUTO.md",
  /memory\/\d{4}-\d{2}-\d{2}\.md/,  // 每日记忆文件
];

export function auditPostCompactionReads(
  readFilePaths: string[],
  workspaceDir: string,
  requiredReads: Array<string | RegExp> = DEFAULT_REQUIRED_READS,
): { passed: boolean; missingPatterns: string[] } {
  const missingPatterns: string[] = [];
  
  for (const required of requiredReads) {
    if (typeof required === "string") {
      const found = readFilePaths.some(p => p === required);
      if (!found) missingPatterns.push(required);
    } else {
      // RegExp 匹配
      const found = readFilePaths.some(p => required.test(p));
      if (!found) missingPatterns.push(required.source);
    }
  }
  
  return { passed: missingPatterns.length === 0, missingPatterns };
}

export function formatAuditWarning(missingPatterns: string[]): string {
  return (
    "⚠️ Post-Compaction Audit: The following required startup files were not read:\n" +
    missingPatterns.map(p => `  - ${p}`).join("\n") +
    "\n\nPlease read them now using the Read tool."
  );
}
```

---

## 6. 改进建议

### 6.1 可观测性增强

| 建议 | 优先级 | 实现难度 |
|------|--------|----------|
| **分布式追踪 ID** | 高 | 中 |
| 为每个请求生成唯一 traceId，贯穿所有子系统和诊断事件 | | |
| **日志采样** | 中 | 低 |
| 在高负载时自动降低日志级别或采样率 | | |
| **结构化错误堆栈** | 高 | 低 |
| 在诊断事件中统一包含错误堆栈和上下文 | | |
| **实时指标仪表板** | 中 | 高 |
| 集成 Grafana/Prometheus 展示实时健康指标 | | |

### 6.2 健康监控增强

| 建议 | 优先级 | 实现难度 |
|------|--------|----------|
| **预测性告警** | 高 | 中 |
| 基于历史数据预测认证过期、Token 耗尽等 | | |
| **依赖健康检查** | 高 | 中 |
| 定期检查 LLM API、数据库、文件系统等依赖 | | |
| **自动基线** | 中 | 高 |
| 学习正常运行模式，自动检测异常行为 | | |
| **多渠道通知** | 中 | 低 |
| 告警通过 Telegram/Slack/Discord 等多渠道发送 | | |

### 6.3 失败恢复增强

| 建议 | 优先级 | 实现难度 |
|------|--------|----------|
| **自适应重试** | 高 | 中 |
| 根据错误类型动态调整重试策略 | | |
| **优雅降级** | 高 | 中 |
| 在模型不可用时降级到较小模型或缓存响应 | | |
| **检查点恢复** | 中 | 高 |
| 长任务定期保存检查点，失败后从中恢复 | | |
| **自动回滚** | 低 | 高 |
| 配置变更后自动验证，失败则回滚 | | |

### 6.4 审计系统增强

| 建议 | 优先级 | 实现难度 |
|------|--------|----------|
| **持续审计** | 高 | 中 |
| 定期自动运行审计，而非手动触发 | | |
| **审计历史** | 中 | 低 |
| 记录审计历史，追踪安全态势变化 | | |
| **合规报告** | 低 | 中 |
| 生成 SOC2/GDPR 等合规报告 | | |
| **漏洞扫描集成** | 中 | 中 |
| 集成依赖漏洞扫描 (npm audit) | | |

---

## 7. 实施路线图

### 阶段 1: 基础加固 (1-2 周)

- [ ] 实现分布式追踪 ID
- [ ] 增强错误堆栈记录
- [ ] 添加依赖健康检查
- [ ] 实现自适应重试策略

### 阶段 2: 监控增强 (2-3 周)

- [ ] 集成 Grafana 仪表板
- [ ] 实现预测性告警
- [ ] 添加多渠道告警通知
- [ ] 实现持续审计机制

### 阶段 3: 高级功能 (4-6 周)

- [ ] 实现检查点恢复
- [ ] 添加优雅降级策略
- [ ] 实现自动基线学习
- [ ] 生成合规报告

---

## 8. 结论

OpenClaw 在 24×7 持久运行方面已经建立了相对完善的体系：

### 优势

1. **分层日志架构** - 文件 + 控制台 + OpenTelemetry 三层
2. **结构化诊断事件** - 13 种事件类型，支持实时追踪
3. **多维度健康监控** - 网关、渠道、会话、队列全覆盖
4. **智能故障恢复** - 故障转移、认证轮换、电路断路器
5. **自动修复机制** - Doctor 命令自动迁移和修复

### 不足

1. **缺少分布式追踪** - 请求链路追踪不完整
2. **被动式监控** - 缺少预测性告警
3. **恢复策略固定** - 缺少自适应调整
4. **审计非持续** - 需要手动触发

### 商用建议

对于商用 Agent 场景，建议优先实施：

1. **分布式追踪 ID** - 提升问题定位效率
2. **预测性告警** - 提前发现潜在问题
3. **自适应重试** - 提高恢复成功率
4. **持续审计** - 确保持续合规

---

## 附录 A: 关键代码位置

| 功能 | 文件路径 |
|------|----------|
| 日志系统 | `src/logging/` |
| 诊断事件 | `src/infra/diagnostic-events.ts` |
| 诊断日志 | `src/logging/diagnostic.ts` |
| 健康检查 | `src/commands/health.ts` |
| 心跳运行 | `src/infra/heartbeat-runner.ts` |
| 故障转移 | `src/agents/failover-error.ts` |
| 认证档案 | `src/agents/auth-profiles/` |
| 重试机制 | `src/infra/retry.ts` |
| 循环检测 | `src/agents/tool-loop-detection.ts` |
| 重启机制 | `src/infra/restart.ts` |
| 安全审计 | `src/security/audit.ts` |
| Doctor | `src/commands/doctor*.ts` |
| 队列管理 | `src/process/command-queue.ts` |

## 附录 B: 配置示例

### 完整配置示例

```json
{
  "logging": {
    "level": "info",
    "file": "/tmp/openclaw/openclaw.log",
    "consoleLevel": "info",
    "consoleStyle": "pretty",
    "redactSensitive": "tools"
  },
  "diagnostics": {
    "enabled": true,
    "flags": ["gateway.*", "agents.*"],
    "otel": {
      "enabled": true,
      "endpoint": "http://otel-collector:4318",
      "serviceName": "openclaw-gateway",
      "traces": true,
      "metrics": true,
      "logs": false,
      "sampleRate": 0.1,
      "flushIntervalMs": 30000
    }
  },
  "agents": {
    "defaults": {
      "heartbeat": {
        "every": "60s",
        "prompt": "HEARTBEAT",
        "target": "last"
      },
      "sandbox": {
        "mode": "non-main",
        "allowlist": ["bash", "read", "write"]
      },
      "tools": {
        "loopDetection": {
          "enabled": true,
          "warningThreshold": 10,
          "criticalThreshold": 20,
          "globalCircuitBreakerThreshold": 30
        }
      }
    }
  },
  "gateway": {
    "auth": {
      "mode": "token",
      "token": "your-secret-token"
    },
    "bind": "loopback",
    "port": 18789
  }
}
```

---

**文档版本**: 1.0  
**最后更新**: 2026 年 2 月 18 日  
**作者**: Qwen Code
